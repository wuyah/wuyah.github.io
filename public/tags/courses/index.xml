<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Courses | Zenan Li&#39;s site</title>
    <link>http://localhost:1313/tags/courses/</link>
      <atom:link href="http://localhost:1313/tags/courses/index.xml" rel="self" type="application/rss+xml" />
    <description>Courses</description>
    <generator>Hugo Blox Builder (https://hugoblox.com)</generator><language>en-us</language><lastBuildDate>Wed, 25 Dec 2024 00:00:00 +0000</lastBuildDate>
    <image>
      <url>http://localhost:1313/media/icon_hu7729264130191091259.png</url>
      <title>Courses</title>
      <link>http://localhost:1313/tags/courses/</link>
    </image>
    
    <item>
      <title>CSE260 - Parallel Computing Portfolio</title>
      <link>http://localhost:1313/project/cse260/</link>
      <pubDate>Wed, 25 Dec 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/project/cse260/</guid>
      <description>


&lt;details class=&#34;print:hidden xl:hidden&#34; open&gt;
  &lt;summary&gt;Table of Contents&lt;/summary&gt;
  &lt;div class=&#34;text-sm&#34;&gt;
  &lt;nav id=&#34;TableOfContents&#34;&gt;
  &lt;ul&gt;
    &lt;li&gt;&lt;a href=&#34;#overview&#34;&gt;Overview&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#project-1-optimizing-matrix-multiplication-with-cpu-vectorization&#34;&gt;Project 1: Optimizing Matrix Multiplication with CPU Vectorization&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#project-2-accelerating-matrix-multiplication-with-cuda&#34;&gt;Project 2: Accelerating Matrix Multiplication with CUDA&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#project-3-distributed-wave-simulation-with-mpi&#34;&gt;Project 3: Distributed Wave Simulation with MPI&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#reflections-and-future-work&#34;&gt;Reflections and Future Work&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#license&#34;&gt;License&lt;/a&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/nav&gt;
  &lt;/div&gt;
&lt;/details&gt;

&lt;h2 id=&#34;overview&#34;&gt;Overview&lt;/h2&gt;
&lt;p&gt;CSE260 delves into the principles and practices of &lt;strong&gt;High-Performance Computing (HPC)&lt;/strong&gt;, emphasizing parallel programming paradigms to solve computationally intensive problems efficiently.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Key Topics Covered&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;CPU Vectorization&lt;/strong&gt;: Leveraging vector extensions for parallel computation on CPUs.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;CUDA Programming&lt;/strong&gt;: Utilizing GPU architectures for accelerated computation.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;MPI (Message Passing Interface)&lt;/strong&gt;: Implementing distributed memory parallelism.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Thanks to Prof. Chin, I learned a lot from this course by praticing in the projects and analising the reasons behind the experiments&amp;rsquo; results&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;project-1-optimizing-matrix-multiplication-with-cpu-vectorization&#34;&gt;Project 1: Optimizing Matrix Multiplication with CPU Vectorization&lt;/h2&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;flex justify-center	&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;alt text&#34; srcset=&#34;
               /project/cse260/image-3_hu9367625775072898446.webp 400w,
               /project/cse260/image-3_hu17786200574989343527.webp 760w,
               /project/cse260/image-3_hu14680535611392509213.webp 1200w&#34;
               src=&#34;http://localhost:1313/project/cse260/image-3_hu9367625775072898446.webp&#34;
               width=&#34;760&#34;
               height=&#34;456&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;

In this project, we optimized matrix multiplication by leveraging CPU vector extensions such as Intel&amp;rsquo;s AVX and ARM&amp;rsquo;s SVE to enhance computational throughput.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Techniques Employed&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Cache Blocking&lt;/strong&gt;: Divided matrices into smaller blocks to fit into the CPU cache, reducing memory access latency.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Vector Intrinsics&lt;/strong&gt;: Utilized vectorized instructions to perform multiple operations per cycle, enhancing performance.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Memory Alignment&lt;/strong&gt;: Ensured data structures were aligned in memory to prevent performance penalties due to misalignment.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Outcomes&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Achieved significant performance improvements, with computation speeds exceeding 20 GFLOPS on ARM Neoverse V1 architecture.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;project-2-accelerating-matrix-multiplication-with-cuda&#34;&gt;Project 2: Accelerating Matrix Multiplication with CUDA&lt;/h2&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;flex justify-center	&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;alt text&#34; srcset=&#34;
               /project/cse260/image-4_hu15383316976014161530.webp 400w,
               /project/cse260/image-4_hu11406393982847062270.webp 760w,
               /project/cse260/image-4_hu17418213089925729560.webp 1200w&#34;
               src=&#34;http://localhost:1313/project/cse260/image-4_hu15383316976014161530.webp&#34;
               width=&#34;512&#34;
               height=&#34;229&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;

This project focused on implementing matrix multiplication on NVIDIA GPUs using CUDA to exploit massive parallelism and achieve high computational throughput.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Approach&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Tiling and Shared Memory&lt;/strong&gt;: Implemented tiling strategies to load matrix sub-blocks into shared memory, minimizing global memory access.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Thread Synchronization&lt;/strong&gt;: Managed synchronization among threads to ensure correct data handling during computation.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Loop Unrolling&lt;/strong&gt;: Applied loop unrolling techniques to reduce loop overhead and increase instruction-level parallelism.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Results&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Achieved performance exceeding 4 TFLOPS on NVIDIA T4 GPUs, demonstrating the effectiveness of GPU acceleration for matrix computations.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;CUDA Performance Graph Placeholder&lt;/em&gt; &lt;!-- Include a graph comparing CUDA performance metrics --&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;project-3-distributed-wave-simulation-with-mpi&#34;&gt;Project 3: Distributed Wave Simulation with MPI&lt;/h2&gt;
&lt;!-- ![alt text](image.png)![alt text](image-1.png)![alt text](image-2.png) --&gt;
&lt;div style=&#34;display: flex; justify-content: center;&#34;&gt;
  &lt;img src=&#34;image.png&#34; alt=&#34;Image 1&#34; width=&#34;30%&#34;&gt;
  &lt;img src=&#34;image-1.png&#34; alt=&#34;Image 2&#34; width=&#34;30%&#34;&gt;
  &lt;img src=&#34;image-2.png&#34; alt=&#34;Image 3&#34; width=&#34;30%&#34;&gt;
&lt;/div&gt;
In this project, we developed a wave propagation simulation using MPI to distribute computations across multiple processors, enhancing scalability and performance.
&lt;p&gt;&lt;strong&gt;Methodology&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Domain Decomposition&lt;/strong&gt;: Partitioned the simulation domain among processors to balance computational load.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Non-blocking Communication&lt;/strong&gt;: Employed MPI&amp;rsquo;s non-blocking communication routines to overlap computation with data exchange, reducing idle times.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Boundary Management&lt;/strong&gt;: Implemented ghost cell exchanges to handle boundary conditions between adjacent partitions.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Achievements&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Maintained strong scaling efficiency above 95% up to 16 cores, indicating effective parallelization.&lt;/li&gt;
&lt;li&gt;Demonstrated minimal communication overhead in weak scaling tests, showcasing good scalability for larger problem sizes.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;MPI Scaling Graph Placeholder&lt;/em&gt; &lt;!-- Include a graph illustrating MPI scaling efficiency --&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;reflections-and-future-work&#34;&gt;Reflections and Future Work&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Key Learnings&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Effective utilization of parallel programming paradigms can lead to significant performance enhancements in computational applications.&lt;/li&gt;
&lt;li&gt;Understanding hardware architectures is crucial for optimizing software performance, particularly in HPC contexts.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Future Directions&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Explore advanced optimization techniques such as asynchronous computations and dynamic load balancing.&lt;/li&gt;
&lt;li&gt;Investigate the integration of multiple parallel programming models to leverage the strengths of each.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;license&#34;&gt;License&lt;/h2&gt;
&lt;p&gt;Copyright 2016-present &lt;a href=&#34;https://georgecushen.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;George Cushen&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Released under the &lt;a href=&#34;https://github.com/HugoBlox/hugo-blox-builder/blob/main/LICENSE.md&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;MIT&lt;/a&gt; license.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>CSE270 - Discret Differential Geometry</title>
      <link>http://localhost:1313/project/cse270/</link>
      <pubDate>Wed, 25 Dec 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/project/cse270/</guid>
      <description>


&lt;details class=&#34;print:hidden xl:hidden&#34; open&gt;
  &lt;summary&gt;Table of Contents&lt;/summary&gt;
  &lt;div class=&#34;text-sm&#34;&gt;
  &lt;nav id=&#34;TableOfContents&#34;&gt;
  &lt;ul&gt;
    &lt;li&gt;&lt;a href=&#34;#overview&#34;&gt;Overview&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#1-discrete-laplacian&#34;&gt;1. Discrete Laplacian&lt;/a&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;a href=&#34;#understanding-the-discrete-laplacian&#34;&gt;Understanding the Discrete Laplacian&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#key-components&#34;&gt;Key Components&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#matrix-construction&#34;&gt;Matrix Construction&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#eigenvalue-analysis&#34;&gt;Eigenvalue Analysis&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#result&#34;&gt;Result&lt;/a&gt;&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#2-parallel-frames-on-space-curves&#34;&gt;2. Parallel Frames on Space Curves&lt;/a&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;a href=&#34;#understanding-parallel-frames&#34;&gt;Understanding Parallel Frames&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#key-components-1&#34;&gt;Key Components&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#implementation-principles&#34;&gt;Implementation Principles&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#result-1&#34;&gt;Result&lt;/a&gt;&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#3-conformal-mapping&#34;&gt;3. Conformal Mapping&lt;/a&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#4-vector-field-design-cross-fields-on-surfaces&#34;&gt;4. Vector Field Design: Cross Fields on Surfaces&lt;/a&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#license&#34;&gt;License&lt;/a&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/nav&gt;
  &lt;/div&gt;
&lt;/details&gt;

&lt;h2 id=&#34;overview&#34;&gt;Overview&lt;/h2&gt;
&lt;p&gt;This course introduces the mathematical principles of geometry, emphasizing coordinate-free representations and the relationships between geometric entities. Prof. Albert Chern offers a comprehensive introduction to Exterior Algebra, Discrete Laplacian, Curves and Surfaces, Hodge Decomposition, Conformal Flattening, and Vector Field Design. Below are my course works, all implemented in Houdini.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;1-discrete-laplacian&#34;&gt;1. Discrete Laplacian&lt;/h2&gt;
&lt;p&gt;The &lt;strong&gt;Discrete Laplacian&lt;/strong&gt; bridges continuous mathematical concepts with their discrete counterparts on 3D meshes. The course work explores the construction of the Discrete Laplacian on the Bunny.obj mesh.&lt;/p&gt;
&lt;h3 id=&#34;understanding-the-discrete-laplacian&#34;&gt;Understanding the Discrete Laplacian&lt;/h3&gt;
&lt;p&gt;The Discrete Laplacian captures both the mesh&amp;rsquo;s connectivity and geometric properties through a combination of:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Cotangent weights for local geometry&lt;/li&gt;
&lt;li&gt;Discrete exterior derivatives for topology&lt;/li&gt;
&lt;li&gt;Hodge star operators for metric information&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;key-components&#34;&gt;Key Components&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Cotangent Weights:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;For vertices $v_i$ and $v_j$ connected by an edge:
\[
     w_{ij} = \frac{1}{2} (\cot \alpha + \cot \beta)
     \]
where $\alpha$ and $\beta$ are opposite angles to the edge&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Discrete Exterior Derivative ($d_0$):&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Maps vertex functions to edge functions&lt;/li&gt;
&lt;li&gt;For an edge $e$ connecting vertices $v_i$ and $v_j$:
\[
     (d₀ f)_e = f(v_j) - f(v_i)
     \]&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Hodge Star Operators:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$star_0$: Operates on vertices, using local area weights&lt;/li&gt;
&lt;li&gt;$star_1$: Operates on edges, using cotangent weights&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;matrix-construction&#34;&gt;Matrix Construction&lt;/h3&gt;
\[
L = d₀^T \star_1 d₀
\]&lt;h3 id=&#34;eigenvalue-analysis&#34;&gt;Eigenvalue Analysis&lt;/h3&gt;
\[
L \mathbf{f} = \lambda \star_0 \mathbf{f}
\]&lt;ul&gt;
&lt;li&gt;Low eigenvalues: Global, smooth variations&lt;/li&gt;
&lt;li&gt;High eigenvalues: Local, oscillatory patterns&lt;/li&gt;
&lt;li&gt;Eigenfunctions: Geometric modes of the mesh&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;result&#34;&gt;Result&lt;/h3&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;flex justify-center	&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;Discrete Laplacian on Bunny.obj&#34; srcset=&#34;
               /project/cse270/hw2_hu9459823660581520825.webp 400w,
               /project/cse270/hw2_hu1646327279027015749.webp 760w,
               /project/cse270/hw2_hu16680938560338288610.webp 1200w&#34;
               src=&#34;http://localhost:1313/project/cse270/hw2_hu9459823660581520825.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;2-parallel-frames-on-space-curves&#34;&gt;2. Parallel Frames on Space Curves&lt;/h2&gt;
&lt;p&gt;The second course work explores &lt;strong&gt;parallel frames&lt;/strong&gt; on discrete space curves, which provide a robust way to define coordinate systems along curves in 3D space.&lt;/p&gt;
&lt;h3 id=&#34;understanding-parallel-frames&#34;&gt;Understanding Parallel Frames&lt;/h3&gt;
&lt;p&gt;Parallel frames offer advantages over traditional Frenet frames by providing smooth transitions and avoiding discontinuities at inflection points.&lt;/p&gt;
&lt;h3 id=&#34;key-components-1&#34;&gt;Key Components&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Discrete Space Curve:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A sequence of points $\gamma_0, \gamma_1, ..., \gamma_{n-1}$ in 3D space&lt;/li&gt;
&lt;li&gt;Connected by edges forming the curve&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Tangent Vectors:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;For each edge $(i, i+1)$:
\[
     T_{i,i+1} = \frac{\gamma_{i+1} - \gamma_i}{|\gamma_{i+1} - \gamma_i|}
     \]&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Frame Definition:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Tangent vector $T_{i-1,i}$&lt;/li&gt;
&lt;li&gt;Normal vector $U_{i-1,i}$ perpendicular to tangent&lt;/li&gt;
&lt;li&gt;Parallel transport ensures minimal twisting&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;implementation-principles&#34;&gt;Implementation Principles&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Frame Transport:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Between edges: Rotate frame about $T_{i-1,i} \times T_{i,i+1}$&lt;/li&gt;
&lt;li&gt;Maintains smoothness while minimizing twist&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Geometric Properties:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Preserves parallel nature of frames&lt;/li&gt;
&lt;li&gt;Minimizes total rotation along curve&lt;/li&gt;
&lt;li&gt;Adapts to curve geometry naturally&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;result-1&#34;&gt;Result&lt;/h3&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;flex justify-center	&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;Parallel Frames Implementation&#34; srcset=&#34;
               /project/cse270/hw3_hu3185987774226379870.webp 400w,
               /project/cse270/hw3_hu3587444980129062844.webp 760w,
               /project/cse270/hw3_hu3772349313569295958.webp 1200w&#34;
               src=&#34;http://localhost:1313/project/cse270/hw3_hu3185987774226379870.webp&#34;
               width=&#34;760&#34;
               height=&#34;574&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;3-conformal-mapping&#34;&gt;3. Conformal Mapping&lt;/h2&gt;
&lt;p&gt;Conformal mapping ensures that texture coordinates applied to a 3D surface preserve angles and local shapes, minimizing distortion. This property is critical for applications like texture mapping, geometric analysis, and visual effects.&lt;/p&gt;
&lt;h4 id=&#34;key-concepts&#34;&gt;&lt;strong&gt;Key Concepts&lt;/strong&gt;&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Conformal Energy:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The conformal energy measures how close a map is to being conformal. It is defined as:
\[
     C[z] = \frac{1}{2}\|dz\|^2 - \text{Area}[z]
     \]
where \(\|dz\|\) represents the Dirichlet energy, and \(\text{Area}[z]\) captures the total area of the mapped surface.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Rayleigh Quotient:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The conformal map is obtained by minimizing the Rayleigh quotient:
\[
     \min_z \frac{z^H C z}{z^H \star_0 z}
     \]
This leads to solving the eigenvalue problem:
\[
     C z = \lambda \star_0 z
     \]&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;implementation-in-houdini&#34;&gt;&lt;strong&gt;Implementation in Houdini&lt;/strong&gt;&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
\[
     C = \frac{1}{2} L - A
     \]&lt;p&gt;
They are same as what we did in section 1.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Eigenvalue Solver:&lt;/strong&gt;
Using a spectral solver, the smallest nonzero eigenvalue and its corresponding eigenvector were computed. This eigenvector defines the conformal map.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Texture Coordinates:&lt;/strong&gt;
The real and imaginary parts of the solution were assigned as \(u\) and \(v\) attributes to the mesh points. These attributes define the conformal texture map.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Visualization:&lt;/strong&gt;
Houdini&amp;rsquo;s texture shaders and displacement shader were used to preview the conformal map and apply textures without distortion.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;result-2&#34;&gt;&lt;strong&gt;Result&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;flex justify-center	&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;Conformal Mapping Implemenation&#34; srcset=&#34;
               /project/cse270/hw4_hu14022350943677464769.webp 400w,
               /project/cse270/hw4_hu4602273259186994280.webp 760w,
               /project/cse270/hw4_hu13528580409088294468.webp 1200w&#34;
               src=&#34;http://localhost:1313/project/cse270/hw4_hu14022350943677464769.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;4-vector-field-design-cross-fields-on-surfaces&#34;&gt;4. Vector Field Design: Cross Fields on Surfaces&lt;/h2&gt;
&lt;p&gt;The final coursework explores the design of &lt;strong&gt;cross fields&lt;/strong&gt; on 3D surfaces, such as the Bunny mesh, using a connection Laplacian approach. Cross fields are essential in applications like quadrilateral remeshing and direction field design.&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&#34;key-concepts-1&#34;&gt;&lt;strong&gt;Key Concepts&lt;/strong&gt;&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Cross Fields:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A cross field is a quarter-turn symmetric vector field, meaning it returns to its original state after a \( \pi/2 \) rotation.&lt;/li&gt;
&lt;li&gt;The field&amp;rsquo;s orientation at each point is encoded as a phase angle, \(@phase\), derived from a complex-valued eigenfunction.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Connection Laplacian:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;To ensure smooth transitions between cross fields at neighboring points, the connection Laplacian incorporates angular offsets \(\alpha_{ij}\), which account for misalignment of reference directions at adjacent points.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h4 id=&#34;implementation&#34;&gt;&lt;strong&gt;Implementation&lt;/strong&gt;&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Connection Weights:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Compute the &lt;strong&gt;Levi-Civita connection&lt;/strong&gt; \(\alpha_{ij}^{LC}\), which defines angular relationships between half-edges.&lt;/li&gt;
&lt;li&gt;Scale the Levi-Civita connection by a factor of 4 to adjust for the quarter-turn symmetry of the cross field.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Covariant Derivative:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Define the derivative \((d_{\nabla}\psi)_{ij} = e^{-i\alpha_{ij}}\psi_j - \psi_i\), where \(\psi\) is the complex-valued function encoding the cross field.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Minimizing Energy:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Solve the smallest eigenvalue problem of the connection Laplacian:
\[
     L\psi = \lambda \star_0 \psi
     \]
where \(L\) is constructed from the covariant derivative, and \(\star_0, \star_1\) are area and cotangent weight matrices.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Visualization:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Extract the phase angle, \(@phase = \text{atan2}(\text{Im}(\psi), \text{Re}(\psi))\), and visualize the cross field as a rotation from the reference half-edge.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h4 id=&#34;result-3&#34;&gt;&lt;strong&gt;Result&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;The smoothest cross field was generated by solving the eigenvalue problem, and singularities were identified and visualized as critical points on the Bunny mesh. This showcases the elegance of geometric processing for practical applications like remeshing and surface parameterization.&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;flex justify-center	&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;Vector Field Design Implementation&#34; srcset=&#34;
               /project/cse270/hw5_hu11804630775578755073.webp 400w,
               /project/cse270/hw5_hu7316688090065964729.webp 760w,
               /project/cse270/hw5_hu2747445893521161779.webp 1200w&#34;
               src=&#34;http://localhost:1313/project/cse270/hw5_hu11804630775578755073.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;license&#34;&gt;License&lt;/h2&gt;
&lt;p&gt;Copyright 2016-present &lt;a href=&#34;https://georgecushen.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;George Cushen&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Released under the &lt;a href=&#34;https://github.com/HugoBlox/hugo-blox-builder/blob/main/LICENSE.md&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;MIT&lt;/a&gt; license.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Disney BSDF - UCSD CSE 272</title>
      <link>http://localhost:1313/project/cse272_disney/</link>
      <pubDate>Wed, 25 Dec 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/project/cse272_disney/</guid>
      <description>


&lt;details class=&#34;print:hidden xl:hidden&#34; open&gt;
  &lt;summary&gt;Table of Contents&lt;/summary&gt;
  &lt;div class=&#34;text-sm&#34;&gt;
  &lt;nav id=&#34;TableOfContents&#34;&gt;
  &lt;ul&gt;
    &lt;li&gt;&lt;a href=&#34;#disney-principled-bsdf&#34;&gt;Disney Principled BSDF&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#volumetric-rendering&#34;&gt;Volumetric Rendering&lt;/a&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;a href=&#34;#volume-rendering-equation&#34;&gt;Volume Rendering Equation&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#break-down&#34;&gt;Break down&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#participanting-media-data-structure&#34;&gt;Participanting Media Data Structure&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#monochromatic-absorption-only-homogeneous-volume&#34;&gt;monochromatic absorption-only homogeneous volume&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#single-monochromatic-homogeneous-volume-with-absorption-and-single-scattering-no-surface-lighting&#34;&gt;Single monochromatic homogeneous volume with absorption and single-scattering, no surface lighting&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#multiple-monochromatic-homogeneous-volumes-with-absorption-and-multiple-scattering-using-only-phase-function-sampling-no-surface-lighting&#34;&gt;Multiple monochromatic homogeneous volumes with absorption and multiple-scattering using only phase function sampling, no surface lighting&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#multiple-monochromatic-homogeneous-volumes-with-absorption-and-multiple-scattering-with-both-phase-function-sampling-and-next-event-estimation-no-surface-lighting&#34;&gt;Multiple monochromatic homogeneous volumes with absorption and multiple-scattering with both phase function sampling and next event estimation, no surface lighting&lt;/a&gt;&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
  &lt;/ul&gt;
&lt;/nav&gt;
  &lt;/div&gt;
&lt;/details&gt;

&lt;h2 id=&#34;disney-principled-bsdf&#34;&gt;Disney Principled BSDF&lt;/h2&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;flex justify-center	&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;Result of disney bsdf.&#34; srcset=&#34;
               /project/cse272_disney/disney_bsdf_array_hu14580244296769990818.webp 400w,
               /project/cse272_disney/disney_bsdf_array_hu15282263902990540985.webp 760w,
               /project/cse272_disney/disney_bsdf_array_hu18050512559318829935.webp 1200w&#34;
               src=&#34;http://localhost:1313/project/cse272_disney/disney_bsdf_array_hu14580244296769990818.webp&#34;
               width=&#34;760&#34;
               height=&#34;570&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;Original handouts: &lt;a href=&#34;https://cseweb.ucsd.edu/~tzli/cse272/wi2025/homework1.pdf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CSE 272 Homework1&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;This is a reproduction of a siggraph 2012 talk &lt;a href=&#34;https://media.disneyanimation.com/uploads/production/publication_asset/48/asset/s2012_pbs_disney_brdf_notes_v3.pdf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Physically-Based Shading at Disney&lt;/a&gt;. This shading model also implemented in Blender. And the lajolla renderer is capable of rendering scenes exported from Blender that have principled material.&lt;/p&gt;
&lt;p&gt;The shading model contains 5 lobes, diffuse, metal, glass, clearcoat and sheen and we sample the lobes based on the principled parameters to make it efficient. For more details, please refer to the handout.&lt;/p&gt;
&lt;h2 id=&#34;volumetric-rendering&#34;&gt;Volumetric Rendering&lt;/h2&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;flex justify-center	&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;Result of a heterogeneous volume with a spectrally varying density over space, rendered
with multiple-scattering&#34; srcset=&#34;
               /project/cse272_disney/image_hu10412752157451466589.webp 400w,
               /project/cse272_disney/image_hu5360276216743737642.webp 760w,
               /project/cse272_disney/image_hu10526316202108566866.webp 1200w&#34;
               src=&#34;http://localhost:1313/project/cse272_disney/image_hu10412752157451466589.webp&#34;
               width=&#34;760&#34;
               height=&#34;570&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;Implemented a Volume Renderer in lajolla.&lt;/p&gt;
&lt;p&gt;The following things are simply same as the handout2&amp;rsquo;s pdf. I write them just for myself for a quicker and better review. (So in the future I can quickly unsderstand what I&amp;rsquo;ve done. :&amp;gt; )&lt;/p&gt;
&lt;h3 id=&#34;volume-rendering-equation&#34;&gt;Volume Rendering Equation&lt;/h3&gt;
$$
\frac{d}{dt}L(\mathbb{p}(t)), \omega) = -(\sigma_a\ p(t) + \sigma_s\ p(t) )L(p(t), \omega) + L_e(p(t), \omega) + \sigma_s\ p(t) \int_{S_2}\rho(p(t), \omega, \omega&#39; )L(p(t), \omega&#39;)d\omega&#39; $$&lt;p&gt;Here $L$ is luminance, $p$ is distance function, $\sigma_\alpha$ is absorption coefficient, $\sigma_s$ is the scattering coefficient. And $\rho$ is the phase function that is like the BSDFs of surface rendering.&lt;/p&gt;
&lt;p&gt;It is scary to understand it at first glance. But there are lot of things we can negelect.&lt;/p&gt;
&lt;h3 id=&#34;break-down&#34;&gt;Break down&lt;/h3&gt;
&lt;p&gt;The euqation can be break down to 4 parts abosroption, emission, in-scattering and out-scattering.&lt;/p&gt;
&lt;p&gt;We can first only consider the absorption part:&lt;/p&gt;
$$
\frac{d}{dt}L_1(\mathbb{p}(t), \omega) = -\sigma_a L_1(p(t), \omega) + L_e(p(t),\omega).
$$&lt;p&gt;This is simply an ODE $ x&#39; = ax + b $, and it have an analytical solution.&lt;/p&gt;
&lt;p&gt;The in-scattering accounts for all lights bounce between the particles along the ray, its just like rendering equation.&lt;/p&gt;
$$
\frac{d}{dt}L_{is}(\mathbb{p}(t)), \omega) = \sigma_s\ p(t) \int_{S_2}\rho(p(t), \omega, \omega&#39; )L(p(t), \omega&#39;)d\omega&#39; $$&lt;p&gt;And the lights also bounce out the ray (lights that is scattered). It is just like the absorption:&lt;/p&gt;
$$
\frac{d}{dt}L_{os}(\mathbb{p}(t), \omega) = -\sigma_s L_{os}(p(t)).
$$&lt;p&gt;So it can also be solved and integrated to the absorption ODE equation.&lt;/p&gt;
&lt;h3 id=&#34;participanting-media-data-structure&#34;&gt;Participanting Media Data Structure&lt;/h3&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;flex justify-center	&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;Data Structure in lajolla&#34; srcset=&#34;
               /project/cse272_disney/image-1_hu9397655088624780366.webp 400w,
               /project/cse272_disney/image-1_hu10623996862874536405.webp 760w,
               /project/cse272_disney/image-1_hu1717314203647437397.webp 1200w&#34;
               src=&#34;http://localhost:1313/project/cse272_disney/image-1_hu9397655088624780366.webp&#34;
               width=&#34;760&#34;
               height=&#34;388&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;Its pretty simple in lajolla of how to get the media information. In each intersection, we record the interior and exterior medium. For the medium, we can get it&amp;rsquo;s sigam_s and sigma_a of position p by some simple search (not using advanced datastructure to accelerate it). Note that we need to handle the ray update carefully at the boundary.&lt;/p&gt;
&lt;h3 id=&#34;monochromatic-absorption-only-homogeneous-volume&#34;&gt;monochromatic absorption-only homogeneous volume&lt;/h3&gt;
&lt;p&gt;Nothing special, we solve the absorption part&amp;rsquo;s ode and apply it.&lt;/p&gt;
$$
L_1(p(t), \omega) =  e^{-\sigma_a t} * L_e(p(t_{hit}))
$$&lt;div style=&#34;text-align: center;&#34;&gt;
    &lt;img src=&#34;image-2.png&#34; alt=&#34;monochromatic absorption-only homogeneous volume&#34; width=&#34;50%&#34;&gt;
&lt;/div&gt;
&lt;h3 id=&#34;single-monochromatic-homogeneous-volume-with-absorption-and-single-scattering-no-surface-lighting&#34;&gt;Single monochromatic homogeneous volume with absorption and single-scattering, no surface lighting&lt;/h3&gt;
$$
L_{scatter1}(\mathbf{p}, \omega) =
\int_{\mathcal{M}} \rho(\mathbf{p}(t), \omega, \omega&#39;) L_e(\mathbf{p}&#39;, \omega&#39;)
\exp(-\sigma_t \|\mathbf{p}(t) - \mathbf{p}&#39;\|) 
\frac{|\omega&#39; \cdot \mathbf{n}_{\mathbf{p}&#39; }|}{\|\mathbf{p}(t) - \mathbf{p}&#39;\|^2}
\operatorname{visible}(\mathbf{p}(t), \mathbf{p}&#39;) d\mathbf{p}&#39;,
$$$$
\omega&#39; = \frac{p&#39;-p(t)}{||p&#39;-p(t)||} 
$$&lt;p&gt;So the full rendering euqation is like this:&lt;/p&gt;
$$
\frac{d}{dt} L_2(\mathbf{p}(t), \omega) = - \sigma_t L_2(\mathbf{p}(t), \omega) + \sigma_s L_{scatter1}(\mathbf{p}, \omega).
$$&lt;p&gt;For now, it is no longer an analytical close form with, but we can solve this by simply using Monte Carlo sampling. To do this, we need to make the form of equation more suitable like a rendering euation we have in normal path tracer.&lt;/p&gt;
$$
L_2(\mathbf{p}(0), \omega) = \int_{0}^{t_{\text{hit}}} \exp(-\sigma_t t) \sigma_s L_{scatter1}(\mathbf{p}, \omega) \, dt + \exp(-\sigma_t t_{\text{hit}}) L_e(\mathbf{p}(t_{\text{hit}})).
$$$$C\int_0^t exp(-\sigma_ts)ds = C(-\frac{\exp(-\sigma_t t )}{\sigma_t} + \frac{1}{\sigma_t})$$&lt;p&gt; should $\rightarrow 1$ when $t \rightarrow +\infty$.
Thus, $C(\frac{1}{\sigma_t}) = 1$. Then, we can get $C = \sigma_t$. So that $p(t)$ should be $\sigma_t exp(-\sigma_ts)$&lt;/p&gt;
&lt;p&gt;Integrating p(t), we can then get the CDF and solve it we can get our sample function.&lt;/p&gt;
$$
t = \frac{log(1-u)}{-\sigma_t}
$$&lt;p&gt;Also, we need to consider if we sample the distance that is larger than t_hit,  by integrating the larger part. (Equation is in hand out, too trival and lazy to type it here.)&lt;/p&gt;
&lt;p&gt;By doing this, The result is like following.&lt;/p&gt;
&lt;div style=&#34;text-align: center;&#34;&gt;
    &lt;img src=&#34;image-3.png&#34; alt=&#34;Single monochromatic homogeneous volume with absorption and single-scattering, no surface lighting&#34; width=&#34;50%&#34;&gt;
&lt;/div&gt;
&lt;p&gt;And the question here asked about the difference of different phase function, I made an simple viusalization:&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;flex justify-center	&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;alt text&#34; srcset=&#34;
               /project/cse272_disney/image-4_hu4341111256203962824.webp 400w,
               /project/cse272_disney/image-4_hu16347955799781603834.webp 760w,
               /project/cse272_disney/image-4_hu3998451930598326225.webp 1200w&#34;
               src=&#34;http://localhost:1313/project/cse272_disney/image-4_hu4341111256203962824.webp&#34;
               width=&#34;760&#34;
               height=&#34;250&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
$$
p(\cos\theta, g) = \frac{1 - g^2}{4\pi (1 + g^2 + 2g\cos\theta)^{3/2}}
$$&lt;p&gt;The g controls how concentrate the phase function is and controls how many lights pass through the medium.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;TODO&lt;/strong&gt;&lt;/em&gt;: &lt;em&gt;Equiangular Sampling&lt;/em&gt; implementation and math analyze.&lt;/p&gt;
&lt;h3 id=&#34;multiple-monochromatic-homogeneous-volumes-with-absorption-and-multiple-scattering-using-only-phase-function-sampling-no-surface-lighting&#34;&gt;Multiple monochromatic homogeneous volumes with absorption and multiple-scattering using only phase function sampling, no surface lighting&lt;/h3&gt;
&lt;p&gt;Then we want to make the scattering recursive and change the direction, but we only sample the scattering.&lt;/p&gt;
&lt;p&gt;To implement this, we need to:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Sample a distance t&lt;/li&gt;
&lt;li&gt;Evaluate $L_{scatter}$&lt;/li&gt;
&lt;li&gt;Sample a new direction&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;And we do it recursively. When implementing, we need to update the medium when the ray hit another index-matching surface.&lt;/p&gt;
&lt;p&gt;This now is a fully MC style process in path tracer and we are familiar with it. We also add a russian roulette here to control the max depth.&lt;/p&gt;
&lt;h3 id=&#34;multiple-monochromatic-homogeneous-volumes-with-absorption-and-multiple-scattering-with-both-phase-function-sampling-and-next-event-estimation-no-surface-lighting&#34;&gt;Multiple monochromatic homogeneous volumes with absorption and multiple-scattering with both phase function sampling and next event estimation, no surface lighting&lt;/h3&gt;
&lt;p&gt;BTW, an extremly long name&amp;hellip;&lt;/p&gt;
&lt;p&gt;now we want to add nee because sampling phase function is very very inefficient. So we want to pick a point on the light and tracing shadow ray (just like we did in path tracer&amp;rsquo;s nee), and get the transmission between them. The process is still easy to understand and simple, if someone is really reading this blog for knowledge, I would recommend to read the handout&amp;rsquo;s pseudo-code and its math.&lt;/p&gt;
&lt;p&gt;But how do we MIS the nee is interesting, we need to multiply the contribution of the MIS weight $\frac{p^2_{phase}}{p^2_{phase} + p^2_{nee}}$ (If you dont know this, you can review the &lt;a href=&#34;https://cseweb.ucsd.edu/~tzli/cse168/sp2023/lectures/16_multiple_importance_sampling.pdf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;MIS&amp;rsquo;s knowledge&lt;/a&gt;.)&lt;/p&gt;
&lt;p&gt;Here our solution is just same as said in handout, we simply store the cumulated pdf and calculated it at the end.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Shader Toy Demo from NUS</title>
      <link>http://localhost:1313/project/shadertoy/</link>
      <pubDate>Wed, 25 Dec 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/project/shadertoy/</guid>
      <description>


&lt;details class=&#34;print:hidden xl:hidden&#34; open&gt;
  &lt;summary&gt;Table of Contents&lt;/summary&gt;
  &lt;div class=&#34;text-sm&#34;&gt;
  &lt;nav id=&#34;TableOfContents&#34;&gt;
  &lt;ul&gt;
    &lt;li&gt;&lt;a href=&#34;#overview&#34;&gt;Overview&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#license&#34;&gt;License&lt;/a&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/nav&gt;
  &lt;/div&gt;
&lt;/details&gt;

&lt;h2 id=&#34;overview&#34;&gt;Overview&lt;/h2&gt;
&lt;p&gt;I have implemented some demos in ShaderToy just for fun. The course work of the NUS-SoC Summer workshop is in this repo: &lt;a href=&#34;https://www.shadertoy.com/view/mdjfRd&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://www.shadertoy.com/view/mdjfRd&lt;/a&gt;.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;license&#34;&gt;License&lt;/h2&gt;
&lt;p&gt;Copyright 2016-present &lt;a href=&#34;https://georgecushen.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;George Cushen&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Released under the &lt;a href=&#34;https://github.com/HugoBlox/hugo-blox-builder/blob/main/LICENSE.md&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;MIT&lt;/a&gt; license.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
